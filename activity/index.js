// console.log("test");

//             _
// _ __   ___ | | _____ _ __ ___   ___  _ __
// | '_ \ / _ \| |/ / _ \ '_ ` _ \ / _ \| '_ \
// | |_) | (_) |   <  __/ | | | | | (_) | | | |
// | .__/ \___/|_|\_\___|_| |_| |_|\___/|_| |_|
// |_|

// console.log("%c This is a colored log", "color: blue; font-size: 16px;");

// console.log(`
// â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
// â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
// â¬œâ¬œâ¬œâ¬›â¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›â¬œâ¬œâ¬œ
// â¬œâ¬œâ¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›â¬œâ¬œ
// â¬œâ¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›â¬œ
// â¬œâ¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›â¬œ
// â¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›â¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›
// â¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›â¬œâ¬œâ¬›ğŸŸ¥ğŸŸ¥ğŸŸ¥ğŸŸ¥â¬›
// â¬›â¬›â¬›â¬›â¬›â¬›â¬œâ¬œâ¬›â¬›â¬›â¬›â¬›â¬›
// â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬›
// â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œ
// â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œ
// â¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œ
// â¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œ
// â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
// â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ `);

console.log(
  `%c
â£·â£¿â£¿â£¶â£¶â¡„â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢ â£´â¢°â£¶â£·â£¿â£¿
â €â ¹â£¿â£¿â£¿â¡„â €â ˆâ “â ¦â£„â¢€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â¡¤â –â Šâ ‰â €â£¸â£¿â£¿â£½â ƒ
â €â €â ˜â£¿â£¿â£‡â €â €â €â €â €â ˜â ¶â£„â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£ â â â €â €â €â €â €â£¿â£¿â£¿â ƒâ €
â €â €â €â ˆâ¢»â£¿â „â €â €â €â €â €â €â ˆâ ³â£„â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â¡¤â ™â â €â €â €â €â €â €â¡¸â£¿â Ÿâ â €â €
â €â €â €â €â €â â¢¾â¡„â €â €â €â €â €â €â €â ˆâ ±â£¦â €â €â €â €â €â €â¢€â£€â£€â£€â£€â¡€â €â €â €â €â €â¢€â¡´â ‹â €â €â €â €â €â €â €â €â£ â Ÿâ â¡€â €â €â €
â €â €â €â €â €â €â €â ‰â ³â¡„â €â €â €â €â €â €â €â ˆâ ³â¡†â£¤â ´â â ›â ‰â ‰â ‰â ‰â ‰â ‰â ‰â ³â †â£¤â£¤â â â €â €â €â €â €â €â¢€â£ â –â â €â €â â €â €â €
â €â €â €â €â €â €â €â €â €â €â ™â ¦â£„â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â¡ â –â ‹â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â ‰â¢³â¡â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢‡â â â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¡¾â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â ˆâ£‡â €â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â¢ â ƒâ €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢¹â¡€â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â¢¸â €â €â €â£ â£¶â –â¢¤â¡€â €â €â €â €â €â €â €â €â €â €â¢ â ´â ¶â£¦â¡„â €â €â¢ˆâ ‡â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â ¾â €â €â¢°â£¾â£·â£€â£°â¡§â €â €â €â €â €â €â €â €â €â €â£¿â£€â£ â£¾â£¿â €â €â €â£§â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â¡Ÿâ €â €â ˆâ »â£â¡©â œâ ƒâ €â €â €â  â£¤â¡¤â €â €â €â €â ¹â ­â£‰â ½â â €â €â €â¡·â €â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â¢€â£¤â ´â ´â£¤â£ â£‡â£¤â£¤â£€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¡€â£¤â£¤â£¼â£€â¡´â¢´â¢¦â£„â €â €â €â €â €â €â €
â €â €â €â €â €â €â¢¸â ƒâ €â €â €â €â¢¹â¡â£€â¡€â ™â£±â¡€â €â €â €â ²â£„â£ â¡´â£’â¢’â£¤â£¤â ´â ‚â €â €â €â¢ â¡â¢â£€â¡€â¢¨â ƒâ €â €â €â €â¢¹â €â €â €â €â €â €
â €â €â €â €â €â €â ˆâ ‰â €â ‰â €â ˆâ ˆâ ‰â ‰â ‰â ‰â ‰â ‰â ‰â ‰â ‰â ˆâ €â ‰â ‰â ‰â ‰â ‰â ‰â €â €â €â €â ˆâ ‰â ‰â ‰â ‰â ‰â ‰â â ˆâ ˆâ ˆâ €â ‰â €â €â €â €â €â €`,
  "color: yellow;"
);
console.log("%c             _", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c _ __   ___ | | _____ _ __ ___   ___  _ __", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c| '_  / _ | |/ / _  '_ ` _  / _ | '_ \\ ", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c| |_) | (_) |   <  __/ | | | | | (_) | | | |", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log(
  "%c| .__/ \\___/|_|\\_\\___|_| |_| |_|\\___/|_| |_|        ",
  "color: #FF69B4; font-size: 16px; font-weight: bold;"
);
console.log(
  "%c|_|                                                    ",
  "color: #FF69B4; font-size: 16px; font-weight: bold;"
);

//POKEMON BASE CLASS

class Pokemon {
  constructor(name, type, level, hp, def) {
    this.name = name;
    this.type = type;
    this.level = level;
    this.hp = hp;
    // this.atk = atk;
    this.def = def;
  }

  attack(opponent) {
    console.log(`${this.name} attacked ${opponent.name}`);
    let lvl = this.level * 2;
  }

  receivedDamage(damage) {
    this.hp -= damage;
    if (this.hp <= 0) {
      console.log(`${this.name} has fainted`);
    } else {
      console.log(`${this.name} has ${this.hp} HP left`);
    }
  }

  heal() {
    let randomhp = Math.floor(Math.random() * (15 - 5)) + 5;
    let defboost = (this.def = +5);
    this.hp = Math.min(this.hp + defboost + randomhp, 100); // THIS CODE LET HP NOT EXCEED 100
    console.log(`${this.name} active unique passive skill and gained [${defboost}] Defense and heal [${randomhp}] HP `);
  }

  calculateDamage(opponentType, minDamage, maxDamage) {
    let isSuperEffective = false;
    const counterEffect = {
      Fire: "Rock",
      Rock: "Water",
      Water: "Grass",
      Grass: "Dark",
      Dark: "Light",
      Light: "Fire",
    };

    if (counterEffect[this.type] === opponentType) {
      isSuperEffective = true;
    }

    const dmgMultiplier = isSuperEffective ? 0.5 : 0.2;
    const damage = Math.floor(this.level * (Math.random() * (maxDamage - minDamage) + minDamage) * dmgMultiplier);

    console.log(
      `${this.name} deals ${damage} ${
        isSuperEffective ? "Critical Damage (Super Effective)" : "Damage"
      } to the Opponent`
    );

    return damage;
  }

  // criticalDamage() {
  //   let damage = this.level * Math.floor(Math.random() * (10 - 7)) + 7; //DEALING CRITCAL HIT ON MASMAHINA
  //   receivedDamage(damage);
  // }

  powerUp() {
    this.hp += 20;
    console.log(`${this.name} use PowerUpğŸ’ª +20 HP â¤ï¸`);
  }

  isDead() {
    return this.hp <= 0;
  }

  revive() {
    this.isDead = false;
    this.hp = 100;
  }
}

//TRAINERS
class Trainer {
  constructor(name) {
    this.name = name;
    this.pokemons = [];
    this.originalPokemons = [];
    this.wins = 0;
    this.losses = 0;
  }

  choosePokemon(pokemon) {
    // if (this.pokemons.length > 5) {
    //   console.log("You can only choose 6 Pokemon");
    // } else {
    this.pokemons.push(pokemon);
    this.originalPokemons.push(pokemon);
    console.log(
      `%c${this.name} add ${pokemon.name} in the Team`,
      "color: red; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px; background-color: #FF69B4;"
    );
    // }
  }

  selectPokemon(i) {
    return this.pokemons[i];
  }

  showPokemon() {
    // console.log(`${this.name}'s Pokemons: `);
    // this.pokemons.forEach((pokemon) => {
    //   console.log(`${pokemon.name}`);
    // });

    console.log(`  ${this.name}'s team: ${this.pokemons.map((pokemon) => pokemon.name)}`);
  }

  showTrainerDetails() {}

  nextPokemon() {
    return this.pokemons.find((pokemon) => !pokemon.isDead());
  }

  pokemonLeft() {
    return this.pokemons.some((pokemon) => !pokemon.isDead());
  }

  deadPokemons() {
    return this.pokemons.filter((pokemon) => pokemon.isDead());
  }

  winCounts() {
    this.wins += 1;
    return console.log(`${this.wins} Wins`);
  }
}

//ADDING SUBCLASS USING POLYMORPSIM AND INHERITANCE
class FirePokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Fire", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use FlameThrowerğŸ’¥ on ${opponent.name}!`,
      "border: 1px solid orange; padding: 2px; border-radius: 2px; background-color: orange; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Rock") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class RockPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Rock", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use RockDriveğŸ’© on ${opponent.name}!`,
      "border: 1px solid brown; padding: 2px; border-radius: 2px; background-color: brown; color: white;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Water") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class WaterPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Water", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use WaterGunğŸ’¦ on ${opponent.name}!`,
      "border: 1px solid skyblue; padding: 2px; border-radius: 2px; background-color: skyblue; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Grass") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class GrassPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Grass", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use VineWhipğŸŒ± on ${opponent.name}!`,
      "border: 1px solid #3E7B27; padding: 2px; border-radius: 2px; background-color: #3E7B27; color: white;"
    );

    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Dark") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class DarkPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Dark", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use BlackHoleğŸŒ‘ on ${opponent.name}!`,
      "border: 1px solid #3E5879; padding: 2px; border-radius: 2px; background-color: #3E5879; color: white;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Light") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class LightPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Light", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use Light Magicâœ¨ on ${opponent.name}!`,
      "border: 1px solid #FFF574; padding: 2px; border-radius: 2px; background-color: #FFF574; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Fire") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

//BATTLEGROND
class Battle {
  //ADD TRAINER TO RECORD THE WINS
  constructor(pokemon1, pokemon2, trainer1, trainer2) {
    this.pokemon1 = pokemon1;
    this.pokemon2 = pokemon2;
    this.trainer1 = trainer1; //ADD THIS TO TRACK USER WIN AND LOOSE
    this.trainer2 = trainer2;
  }

  //START THE BATTLE BETWEEN THE PAIRED TRAINERS
  startBattle() {
    //console.log(`The battle Between ${this.trainer1.name} âŒ ${this.trainer2.name} has begun! `);
    console.log("");

    let game = true;

    while (game) {
      let pokemon1 = this.trainer1.nextPokemon();
      let pokemon2 = this.trainer2.nextPokemon();

      //CHECK IF TRAINER HAVE REMAINING POKEMON IF DONT THE MATCH ENDS
      if (!pokemon1 || !pokemon2) {
        game = false;
        console.log("NO POKEMON REMAINING");
        break;
      }

      console.log(``);
      console.log(
        `%c ${this.trainer1.name}'s ${pokemon1.name} is battling against ${this.trainer2.name}'s ${pokemon2.name}! `,
        "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
      );

      //START THE BATTLE FOR ALL TRAINERS POKEMONS
      let battle = new SingleBattle(pokemon1, pokemon2);
      battle.startBattle();

      //CREATING NEW ARRAY TO REMOVE DEAD POKEMON FOR EACH TRAINER 1
      if (pokemon1.isDead()) {
        this.trainer1.pokemons = this.trainer1.pokemons.filter((pokemon) => pokemon !== pokemon1);
      }
      //CREATING NEW ARRAY TO REMOVE DEAD POKEMON FOR TRAINER 2
      if (pokemon2.isDead()) {
        this.trainer2.pokemons = this.trainer2.pokemons.filter((pokemon) => pokemon !== pokemon2);
      }

      //CHECK IF TRAINER 1 HAVE REMAINING POKEMON
      if (this.trainer1.pokemonLeft()) {
        console.log(`${this.trainer1.name} has ${this.trainer1.pokemons.length} PokÃ©mon left!`);
      } else {
        //IF NO POKEMON LEFT THE MATCH ENDS
        console.log(`${this.trainer1.name} has no more PokÃ©mon left!`);
        game = false;
      }

      //CHECK IF TRAINER 2 HAVE REMAINING POKEMON
      if (this.trainer2.pokemonLeft()) {
        console.log(`${this.trainer2.name} has ${this.trainer2.pokemons.length} PokÃ©mon left!`);
      } else {
        //IF NO POKEMON LEFT THE MATCH ENDS
        console.log(`${this.trainer2.name} has no more PokÃ©mon left!`);
        game = false;
      }
    }

    //DETERMINE THE WINNER OF THE MATCH IF TRAINER1 HAVE REMAINING POKEMON
    if (this.trainer1.pokemonLeft()) {
      console.log(`${this.trainer1.name} wins the battle!`);
      this.trainer1.wins++;
    } else {
      console.log(`${this.trainer2.name} wins the battle!`);
      this.trainer2.wins++;
    }
  }
}

//CLASS OF INDIVIDUAL POKEMON BATTLE
class SingleBattle {
  constructor(pokemon1, pokemon2) {
    this.pokemon1 = pokemon1;
    this.pokemon2 = pokemon2;
  }

  //STAR THE BATTLE
  startBattle() {
    let game = true;

    while (game) {
      console.log(``);

      //SHOW POKEMON HP BEFORE EACH TURN
      console.log(`${this.pokemon1.name} HP: ${this.pokemon1.hp}`);
      console.log(`${this.pokemon2.name} HP: ${this.pokemon2.hp}`);
      console.log(
        `ğŸ”„ %c${this.pokemon1.name}` + " Turn to Attack",
        "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
      );

      this.pokemon1.attack(this.pokemon2);

      if (this.pokemon2.hp <= 0) {
        // console.log(`${this.pokemon2.name} has fainted!`);
        game = false;
        this.pokemon1.level++;
        console.log(`${this.pokemon1.name} has leveled up to level ${this.pokemon1.level}!`);
      } else {
        console.log(``);
        console.log(
          `ğŸ”„ %c${this.pokemon2.name}` + " Turn to Attack",
          "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
        );
        this.pokemon2.attack(this.pokemon1);

        if (this.pokemon1.hp <= 0) {
          // console.log(`${this.pokemon1.name} has fainted!`);
          game = false;
          this.pokemon2.level++;
          console.log(`${this.pokemon2.name} has leveled up to level ${this.pokemon2.level}!`);
        }
      }
    }
  }
}

//TOURNAMENT MODE
class Tournament {
  constructor(trainers) {
    this.trainers = trainers;
  }

  // Modify the reviveAndHealPokemon function to use originalPokemons
  reviveAndHealPokemon(trainers) {
    trainers.forEach((trainer) => {
      // Get all PokÃ©mon, including dead ones
      const allPokemon = trainer.originalPokemons;

      // Revive and heal all PokÃ©mon
      allPokemon.forEach((pokemon) => {
        pokemon.hp = 100; // Revive and heal PokÃ©mon
        console.log(
          `%c${trainer.name}'s ${pokemon.name} has been revived and fully healed!`,
          "color: white; border: 1px solid white; padding: 2px; border-radius: 2px;"
        );
      });

      // Update the trainer's lineup with all revived PokÃ©mon
      trainer.pokemons = allPokemon;
    });
  }

  //TOURNAMENT START
  startTournament() {
    //LOOP UNTIL ONE TRAINER REMAINS AND BECOME THE OVERALL WINNER
    while (true) {
      //FILTER OUT TRAINERS WITH AND HOW MANY POKEMONSREMAINING
      const remainingTrainers = this.trainers.filter((trainer) =>
        trainer.pokemons.some((pokemon) => !pokemon.isDead())
      );

      //CHECK IF THERE IS ONLY ONE TRAINER LEFT
      if (remainingTrainers.length <= 1) {
        //SHOW WINNER IF ONLY ONE TRAINER LEFT
        if (remainingTrainers.length === 1) {
          console.log(
            `%c ğŸ‘‘ The tournament is over! ${remainingTrainers[0].name}  is the overall winner! and Won ${remainingTrainers[0].wins} Matches ğŸ‘‘`,
            "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 30px; "
          );
        } else {
          console.log(`No winner, all trainers are out of PokÃ©mon.`);
        }
        break;
      }

      //MATCH UP THE TRAINERS BASED ON COUNT AND MATCH IS DIFFERENT DEPENDING ON COUNT
      console.log(`${remainingTrainers.length} trainers remaining in the tournament.`);
      if (remainingTrainers.length === 3) {
        this.roundRobin(remainingTrainers);
      } else {
        this.bracketMatch(remainingTrainers);
      }
    }
  }

  //BRACKET MATCH
  bracketMatch(trainers) {
    //MATCH UP THE TRAINERS IN PAIR ACCORDING TO INDEX
    //WERE PARINGI UP TRAINERS IN BRACKET FORMAT WHERE EACH PAIR IS CONSIST OF TWO TRAINERS
    console.log("");
    console.log("BRACKET MATCH WILL BEGIN");
    for (let i = 0; i < trainers.length - 1; i += 2) {
      const trainer1 = trainers[i];
      const trainer2 = trainers[i + 1];
      console.log("");
      console.log(
        `       %c âš”ï¸  Match [${i + 1}] between ${trainer1.name} ğŸ†š ${trainer2.name}
        }-Wins âš”ï¸ `,
        "border: 1px solid #87CEEB; padding: 2px; border-radius: 2px; font-size: 20px; "
      );

      this.startMatch(trainer1, trainer2);
    }

    //IF THE NUMBER OF TRAINERS IS ODD THEN THE LAST TRAINER WILL BE MOVE INTO THE SEMI-FINAL
    if (trainers.length % 2 !== 0) {
      const lastTrainer = trainers[trainers.length - 1];
      console.log(
        `       %c  ${lastTrainer.name} Won by Default and Move into the Round Robin Format!`,
        "border: 1px solid black; padding: 2px; border-radius: 2px; font-size: 20px; "
      );
    }
  }

  //ROUND ROBIN
  roundRobin(trainers) {
    console.log("");
    console.log(
      "c%ğŸ†ROUND ROBIN MATCH WILL BEGINğŸ†",
      "border: 1px solid white; padding: 2px; border-radius: 2px; font-size: 25px; "
    );

    this.reviveAndHealPokemon(trainers); // Revive and heal all PokÃ©mon

    // Revive and fully heal all PokÃ©mon of remaining trainers
    // trainers.forEach((trainer) => {
    //   trainer.pokemons.forEach((pokemon) => {
    //     if (pokemon.isDead()) {
    //       // Revive fainted PokÃ©mon
    //       pokemon.hp = 100; // Assume 100 is the max HP
    //       console.log(`${trainer.name}'s ${pokemon.name} has been revived and fully healed!`);
    //     } else {
    //       // Heal PokÃ©mon that are not fainted
    //       pokemon.hp = 100;
    //       console.log(`${trainer.name}'s ${pokemon.name} has been fully healed!`);
    //     }
    //   });
    // });

    // Initialize a map to track wins for each trainer
    const winsMap = new Map();
    trainers.forEach((trainer) => winsMap.set(trainer, 0));

    //MATCH UP THE TRAINERS IN PAIR ACCORDING TO INDEX LOOP UNTIL THE LAST INDEX
    //THIS 2 FOR LOOP WILL RESULT 1 TRAINER WILL MATCH TO ALL REMAINING PLAYERS
    for (let i = 0; i < trainers.length; i++) {
      for (let j = i + 1; j < trainers.length; j++) {
        const trainer1 = trainers[i];
        const trainer2 = trainers[j];
        // Revive and heal all PokÃ©mon for both trainers

        console.log("");
        console.log(
          `       %c âš”ï¸  Match [${i + 1}] between ${trainer1.name} ğŸ†š ${trainer2.name}
          }-Wins âš”ï¸ `,
          "border: 1px solid #87CEEB; padding: 2px; border-radius: 2px; font-size: 20px; "
        );
        this.reviveAndHealPokemon([trainer1, trainer2]);

        // Start a battle between trainers
        const battle = new Battle(trainer1.nextPokemon(), trainer2.nextPokemon(), trainer1, trainer2);
        battle.startBattle();

        // Update wins for the winner
        if (trainer1.pokemonLeft()) {
          winsMap.set(trainer1, winsMap.get(trainer1) + 1);
        } else if (trainer2.pokemonLeft()) {
          winsMap.set(trainer2, winsMap.get(trainer2) + 1);
        }

        console.log(
          `ğŸ† ${trainer1.name} Wins: ${winsMap.get(trainer1)} | ${trainer2.name} Wins: ${winsMap.get(trainer2)}`
        );
      }
    }
  }

  //START THE MATCH
  startMatch(trainer1, trainer2) {
    // Select valid PokÃ©mon that is not dead
    const pokemon1 = trainer1.nextPokemon();
    const pokemon2 = trainer2.nextPokemon();

    // ERROR HANDLING CHECK IF ONE OR BOTH TRAINERS HAVE NO VALID POKEMON
    if (!pokemon1 || !pokemon2) {
      console.log(`Match cannot proceed. One or both trainers have no valid PokÃ©mon.`);
      return;
    }

    //RANDOM POKEMON TO RECEIEVED POWER UP
    const powerUpPokemon = Math.random() < 0.5 ? pokemon1 : pokemon2;
    powerUpPokemon.powerUp();
    console.log(`ğŸ”¥ ${powerUpPokemon.name} recieved power up before the battle begins`);

    const battle = new Battle(pokemon1, pokemon2, trainer1, trainer2);
    battle.startBattle();

    // Remove fainted PokÃ©mon
    trainer1.pokemons = trainer1.pokemons.filter((pokemon) => !pokemon.isDead());

    trainer2.pokemons = trainer2.pokemons.filter((pokemon) => !pokemon.isDead());

    if (trainer1.pokemons.length === 0) {
      console.log(`${trainer1.name} is out of the tournament!`);
    }

    if (trainer2.pokemons.length === 0) {
      console.log(`${trainer2.name} is out of the tournament!`);
    }

    //RETURN THE WINNER OF THE MATCH
    return trainer1.pokemons.length > 0 ? trainer1 : trainer2;
  }
}

//CREATING POKEMON/ INSTANTIATE POKEMON
const charizard = new FirePokemon("Charizard", 10, 100, 0);
const stone = new RockPokemon("Stone", 10, 100, 0);
const starfish = new WaterPokemon("Starfish", 10, 100, 0);
const birdy = new GrassPokemon("Birdy", 10, 100, 0);
const gengar = new DarkPokemon("Gengar", 10, 100);
const charmander = new FirePokemon("Charmander", 10, 100, 0);
const machop = new RockPokemon("Machop", 10, 100, 0);
const squirtle = new WaterPokemon("Squirtle", 10, 100, 0);
const zubat = new GrassPokemon("Zubat", 10, 100, 0);
const mew = new DarkPokemon("Mew", 10, 100, 0);
const necrozma = new LightPokemon("Necrozma", 10, 100, 0);
const cosmoem = new LightPokemon("Cosmoem", 10, 100, 0);

//ARRAY OF POKEMON
let allPokemon = [
  charizard,
  stone,
  starfish,
  birdy,
  gengar,
  charmander,
  machop,
  squirtle,
  zubat,
  mew,
  necrozma,
  cosmoem,
];

//PROMTING IN FIRST ASK USER TO PUT # OF TRAINER AND POKEMON
//ADD DESIGN LATER
function startGame() {
  const trainers = [];

  // PROMPT ASK USER TO PUT # OF TRAINER
  let numberOfTrainer;
  while (isNaN(numberOfTrainer) || numberOfTrainer < 3 || numberOfTrainer > 5) {
    numberOfTrainer = parseInt(prompt("Enter Number of Trainers (Max 5)"));
    if (isNaN(numberOfTrainer)) {
      console.log("%cInvalid input. Please enter a number.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfTrainer < 3) {
      console.log("%cMinimum number of trainers is 3.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfTrainer > 5) {
      console.log("%cMaximum number of trainers is 5.", "color: red; font-weight: bold; font-size: 50px;");
    }
  }
  console.log(`%cDONE SELECTING NUMBER OF TRAINERS `, "color: green; font-weight: bold; font-size: 50px;");

  // PROMT ASK USER TO PUT # OF POKEMON
  let numberOfPokemon;
  //ERROR HANDLING IF INPUT IS NEGATIVE OR GREATER THAN 5
  while (isNaN(numberOfPokemon) || numberOfPokemon < 2 || numberOfPokemon > 5) {
    numberOfPokemon = parseInt(prompt("Enter Number of Pokekon (Max 5)"));
    if (isNaN(numberOfPokemon)) {
      console.log("%cInvalid input. Please enter a number.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfPokemon < 2) {
      console.log("%cMinimum number of PokÃ©mon is 2.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfPokemon > 5) {
      console.log("%cMaximum number of PokÃ©mon is 5.", "color: red; font-weight: bold; font-size: 50px;");
    }
  }
  console.log(`%cDONE SELECTING NUMBER OF POKEMONS `, "color: green; font-weight: bold; font-size: 50px;");

  // ADDING TRAINER NAME AND SELECTING POKEMON INSIDE A LOOP
  for (let i = 1; i <= numberOfTrainer; i++) {
    const name = prompt(`Enter the trainer ${i} Name: `);
    const newTrainer = new Trainer(name);
    trainers.push(newTrainer);

    // SELECTING POKEMON AFTER ADDING TRAINER
    for (let j = 1; j <= numberOfPokemon; j++) {
      // SHOWING ALL AVAILABLE POKEMON USING FOREACH FUNCTION
      console.log("");
      console.log("");
      console.log(
        `%c ğŸ‘‡SELECT POKEMON[${j}] POKEMON FROM AVAILABLE POKEMON FOR TRAINER: â–¶${newTrainer.name}â—€`,
        "color: white; font-weight: bold; font-size: 30px; border: 1px solid white; padding: 2px; border-radius: 10px;"
      );

      // FILTERING OUT ALL POKEMON THAT ARE ALREADY IN A TRAINER SO POKEMON WILL NOT REPEAT
      const availablePokemon = allPokemon.filter(
        (pokemon) => !trainers.some((trainer) => trainer.pokemons.includes(pokemon))
      );

      //SHOW ALL AVAILABLE POKEMON
      availablePokemon.forEach((pokemon, index) => {
        console.log(
          `%c[${index + 1}] â—“${pokemon.name} | â­LEVEL: ${pokemon.level} | âš›TYPE:${pokemon.type} | â¤ï¸HP:${pokemon.hp}`,
          "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
        );
      });

      // GETTING INPUT FROM USER TO SELECT POKEMON AND ENTER THE INDEX
      let selectedPokemonIndex;
      while (
        isNaN(selectedPokemonIndex) ||
        selectedPokemonIndex < 1 ||
        selectedPokemonIndex > availablePokemon.length
      ) {
        selectedPokemonIndex = parseInt(prompt(`Select Available Pokemon for ${newTrainer.name}: `));
        if (isNaN(selectedPokemonIndex)) {
          console.log("Invalid input. Please enter a number.");
        } else if (selectedPokemonIndex < 1) {
          console.log("Invalid input. Please enter a number between 1 and", availablePokemon.length);
        } else if (selectedPokemonIndex > availablePokemon.length) {
          console.log("Invalid input. Please enter a number between 1 and", availablePokemon.length);
        }
      }

      const selectedPokemon = availablePokemon[selectedPokemonIndex - 1]; // Subtract 1 to get the correct index based on user input

      console.log("");
      console.log(
        `%c${newTrainer.name} choose ${selectedPokemon.name} as their pokemon`,
        "color: red; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px; background-color: #FF69B4;"
      );
      newTrainer.choosePokemon(selectedPokemon);
    }
  }

  console.log("");

  // SHOWING ALL TEAM AND THEIR POKEMON USING MAP FUNCTION
  console.log(`%câ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â€¢â—â€¢â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`, "color: red; font-weight: bold; font-size: 20px;");

  trainers.forEach((trainer) =>
    console.log(
      `   %c${trainer.name}'s team: ${trainer.pokemons.map((pokemon) => pokemon.name)}`,
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    )
  );

  console.log(`%câ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â€¢â—â€¢â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`, "color: red; font-weight: bold; font-size: 20px;");

  // MENU
  while (true) {
    console.log("");

    console.log(
      "%câ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ã€ŠMAIN MENUã€‹â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
      "color: yellow; font-weight: bold; font-size: 20px;"
    );
    console.log(
      "          %c[1] - View Trainers' PokÃ©mon",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[2] - Start Tournament",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[3] - Exit",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "%câ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ã€Šâœ§ã€‹â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
      "color: yellow; font-weight: bold; font-size: 20px;"
    );

    let choice;
    while (isNaN(choice) || choice < 1 || choice > 3) {
      choice = parseInt(prompt("Enter your choice"));
      if (isNaN(choice)) {
        console.log("Invalid input. Please enter a number.");
      } else if (choice < 1) {
        console.log("Please choose a valid option.");
      } else if (choice > 3) {
        console.log("Please choose a valid option.");
      }
    }

    switch (choice) {
      case 1:
        trainers.forEach((trainer) => {
          console.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â€¢â—â€¢â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
          console.log(`  Trainer: ${trainer.name}`);
          trainer.showPokemon();
          console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â€¢â—â€¢â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        });
        break;
      case 2:
        const tournament = new Tournament(trainers);
        tournament.startTournament();
        break;
      case 3:
        console.log("");
        console.log("Exiting...");
        return;
    }
  }
}

startGame();
