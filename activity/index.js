// console.log("test");

//             _
// _ __   ___ | | _____ _ __ ___   ___  _ __
// | '_ \ / _ \| |/ / _ \ '_ ` _ \ / _ \| '_ \
// | |_) | (_) |   <  __/ | | | | | (_) | | | |
// | .__/ \___/|_|\_\___|_| |_| |_|\___/|_| |_|
// |_|

// console.log("%c This is a colored log", "color: blue; font-size: 16px;");

// console.log(`
// ⬜⬜⬜⬜⬜⬛⬛⬛⬛⬜⬜⬜⬜⬜
// ⬜⬜⬜⬜⬜⬛⬛⬛⬛⬜⬜⬜⬜⬜
// ⬜⬜⬜⬛⬛🟥🟥🟥🟥🟥⬛⬜⬜⬜
// ⬜⬜⬛🟥🟥🟥🟥🟥🟥🟥🟥⬛⬜⬜
// ⬜⬛🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥⬛⬜
// ⬜⬛🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥⬛⬜
// ⬛🟥🟥🟥🟥🟥⬛⬛🟥🟥🟥🟥🟥⬛
// ⬛🟥🟥🟥🟥⬛⬜⬜⬛🟥🟥🟥🟥⬛
// ⬛⬛⬛⬛⬛⬛⬜⬜⬛⬛⬛⬛⬛⬛
// ⬛⬜⬜⬜⬜⬜⬛⬛⬜⬜⬜⬜⬜⬛
// ⬜⬛⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬛⬜
// ⬜⬛⬜⬜⬜⬜⬜⬜⬜⬜⬜⬜⬛⬜
// ⬜⬜⬛⬜⬜⬜⬜⬜⬜⬜⬜⬛⬜⬜
// ⬜⬜⬜⬛⬛⬜⬜⬜⬜⬛⬛⬜⬜⬜
// ⬜⬜⬜⬜⬜⬛⬛⬛⬛⬜⬜⬜⬜⬜
// ⬜⬜⬜⬜⬜⬛⬛⬛⬛⬜⬜⬜⬜⬜ `);

console.log(
  `%c
⣷⣿⣿⣶⣶⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣴⢰⣶⣷⣿⣿
⠀⠹⣿⣿⣿⡄⠀⠈⠓⠦⣄⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠖⠊⠉⠀⣸⣿⣿⣽⠃
⠀⠀⠘⣿⣿⣇⠀⠀⠀⠀⠀⠘⠶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⣿⣿⣿⠃⠀
⠀⠀⠀⠈⢻⣿⠄⠀⠀⠀⠀⠀⠀⠈⠳⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠙⠁⠀⠀⠀⠀⠀⠀⡸⣿⠟⠁⠀⠀
⠀⠀⠀⠀⠀⠁⢾⡄⠀⠀⠀⠀⠀⠀⠀⠈⠱⣦⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⣠⠟⠁⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠉⠳⡄⠀⠀⠀⠀⠀⠀⠀⠈⠳⡆⣤⠴⠞⠛⠉⠉⠉⠉⠉⠉⠉⠳⠆⣤⣤⠞⠁⠀⠀⠀⠀⠀⠀⢀⣠⠖⠁⠀⠀⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠖⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢳⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⣠⣶⠖⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠴⠶⣦⡄⠀⠀⢈⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠾⠀⠀⢰⣾⣷⣀⣰⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣀⣠⣾⣿⠀⠀⠀⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡟⠀⠀⠈⠻⣍⡩⠜⠃⠀⠀⠀⠠⣤⡤⠀⠀⠀⠀⠹⠭⣉⠽⠏⠀⠀⠀⡷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⣤⠴⠴⣤⣠⣇⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣤⣤⣼⣀⡴⢴⢦⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠀⢹⡁⣀⡀⠙⣱⡀⠀⠀⠀⠲⣄⣠⡴⣒⢒⣤⣤⠴⠂⠀⠀⠀⢠⡞⢁⣀⡀⢨⠃⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠈⠉⠀⠉⠀⠈⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠈⠀⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠁⠈⠈⠈⠀⠉⠀⠀⠀⠀⠀⠀`,
  "color: yellow;"
);
console.log("%c             _", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c _ __   ___ | | _____ _ __ ___   ___  _ __", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c| '_  / _ | |/ / _  '_ ` _  / _ | '_ \\ ", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c| |_) | (_) |   <  __/ | | | | | (_) | | | |", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log(
  "%c| .__/ \\___/|_|\\_\\___|_| |_| |_|\\___/|_| |_|        ",
  "color: #FF69B4; font-size: 16px; font-weight: bold;"
);
console.log(
  "%c|_|                                                    ",
  "color: #FF69B4; font-size: 16px; font-weight: bold;"
);

//POKEMON BASE CLASS

class Pokemon {
  constructor(name, type, level, hp, def) {
    this.name = name;
    this.type = type;
    this.level = level;
    this.hp = hp;
    // this.atk = atk;
    this.def = def;
  }

  attack(opponent) {
    console.log(`${this.name} attacked ${opponent.name}`);
    let lvl = this.level * 2;
  }

  receivedDamage(damage) {
    this.hp -= damage;
    if (this.hp <= 0) {
      console.log(`${this.name} has fainted`);
    } else {
      console.log(`${this.name} has ${this.hp} HP left`);
    }
  }

  heal() {
    let randomhp = Math.floor(Math.random() * (15 - 5)) + 5;
    let defboost = (this.def = +5);
    this.hp = Math.min(this.hp + defboost + randomhp, 100); // THIS CODE LET HP NOT EXCEED 100
    console.log(`${this.name} active unique passive skill and gained [${defboost}] Defense and heal [${randomhp}] HP `);
  }

  calculateDamage(opponentType, minDamage, maxDamage) {
    let isSuperEffective = false;
    const counterEffect = {
      Fire: "Rock",
      Rock: "Water",
      Water: "Grass",
      Grass: "Dark",
      Dark: "Light",
      Light: "Fire",
    };

    if (counterEffect[this.type] === opponentType) {
      isSuperEffective = true;
    }

    const dmgMultiplier = isSuperEffective ? 0.5 : 0.2;
    const damage = Math.floor(this.level * (Math.random() * (maxDamage - minDamage) + minDamage) * dmgMultiplier);

    console.log(
      `${this.name} deals ${damage} ${
        isSuperEffective ? "Critical Damage (Super Effective)" : "Damage"
      } to the Opponent`
    );

    return damage;
  }

  // criticalDamage() {
  //   let damage = this.level * Math.floor(Math.random() * (10 - 7)) + 7; //DEALING CRITCAL HIT ON MASMAHINA
  //   receivedDamage(damage);
  // }

  powerUp() {
    this.hp += 20;
    console.log(`${this.name} use PowerUp💪 +20 HP ❤️`);
  }

  isDead() {
    return this.hp <= 0;
  }

  revive() {
    this.isDead = false;
    this.hp = 100;
  }
}

//TRAINERS
class Trainer {
  constructor(name) {
    this.name = name;
    this.pokemons = [];
    this.originalPokemons = [];
    this.wins = 0;
    this.losses = 0;
  }

  choosePokemon(pokemon) {
    // if (this.pokemons.length > 5) {
    //   console.log("You can only choose 6 Pokemon");
    // } else {
    this.pokemons.push(pokemon);
    this.originalPokemons.push(pokemon);
    console.log(
      `%c${this.name} add ${pokemon.name} in the Team`,
      "color: red; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px; background-color: #FF69B4;"
    );
    // }
  }

  selectPokemon(i) {
    return this.pokemons[i];
  }

  showPokemon() {
    // console.log(`${this.name}'s Pokemons: `);
    // this.pokemons.forEach((pokemon) => {
    //   console.log(`${pokemon.name}`);
    // });

    console.log(`  ${this.name}'s team: ${this.pokemons.map((pokemon) => pokemon.name)}`);
  }

  showTrainerDetails() {}

  nextPokemon() {
    return this.pokemons.find((pokemon) => !pokemon.isDead());
  }

  pokemonLeft() {
    return this.pokemons.some((pokemon) => !pokemon.isDead());
  }

  deadPokemons() {
    return this.pokemons.filter((pokemon) => pokemon.isDead());
  }

  winCounts() {
    this.wins += 1;
    return console.log(`${this.wins} Wins`);
  }
}

//ADDING SUBCLASS USING POLYMORPSIM AND INHERITANCE
class FirePokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Fire", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use FlameThrower💥 on ${opponent.name}!`,
      "border: 1px solid orange; padding: 2px; border-radius: 2px; background-color: orange; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Rock") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class RockPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Rock", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use RockDrive💩 on ${opponent.name}!`,
      "border: 1px solid brown; padding: 2px; border-radius: 2px; background-color: brown; color: white;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Water") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class WaterPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Water", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use WaterGun💦 on ${opponent.name}!`,
      "border: 1px solid skyblue; padding: 2px; border-radius: 2px; background-color: skyblue; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Grass") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class GrassPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Grass", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use VineWhip🌱 on ${opponent.name}!`,
      "border: 1px solid #3E7B27; padding: 2px; border-radius: 2px; background-color: #3E7B27; color: white;"
    );

    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Dark") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class DarkPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Dark", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use BlackHole🌑 on ${opponent.name}!`,
      "border: 1px solid #3E5879; padding: 2px; border-radius: 2px; background-color: #3E5879; color: white;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Light") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class LightPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Light", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use Light Magic✨ on ${opponent.name}!`,
      "border: 1px solid #FFF574; padding: 2px; border-radius: 2px; background-color: #FFF574; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Fire") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

//BATTLEGROND
class Battle {
  //ADD TRAINER TO RECORD THE WINS
  constructor(pokemon1, pokemon2, trainer1, trainer2) {
    this.pokemon1 = pokemon1;
    this.pokemon2 = pokemon2;
    this.trainer1 = trainer1; //ADD THIS TO TRACK USER WIN AND LOOSE
    this.trainer2 = trainer2;
  }

  //START THE BATTLE BETWEEN THE PAIRED TRAINERS
  startBattle() {
    //console.log(`The battle Between ${this.trainer1.name} ❌ ${this.trainer2.name} has begun! `);
    console.log("");

    let game = true;

    while (game) {
      let pokemon1 = this.trainer1.nextPokemon();
      let pokemon2 = this.trainer2.nextPokemon();

      //CHECK IF TRAINER HAVE REMAINING POKEMON IF DONT THE MATCH ENDS
      if (!pokemon1 || !pokemon2) {
        game = false;
        console.log("NO POKEMON REMAINING");
        break;
      }

      console.log(``);
      console.log(
        `%c ${this.trainer1.name}'s ${pokemon1.name} is battling against ${this.trainer2.name}'s ${pokemon2.name}! `,
        "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
      );

      //START THE BATTLE FOR ALL TRAINERS POKEMONS
      let battle = new SingleBattle(pokemon1, pokemon2);
      battle.startBattle();

      //CREATING NEW ARRAY TO REMOVE DEAD POKEMON FOR EACH TRAINER 1
      if (pokemon1.isDead()) {
        this.trainer1.pokemons = this.trainer1.pokemons.filter((pokemon) => pokemon !== pokemon1);
      }
      //CREATING NEW ARRAY TO REMOVE DEAD POKEMON FOR TRAINER 2
      if (pokemon2.isDead()) {
        this.trainer2.pokemons = this.trainer2.pokemons.filter((pokemon) => pokemon !== pokemon2);
      }

      //CHECK IF TRAINER 1 HAVE REMAINING POKEMON
      if (this.trainer1.pokemonLeft()) {
        console.log(`${this.trainer1.name} has ${this.trainer1.pokemons.length} Pokémon left!`);
      } else {
        //IF NO POKEMON LEFT THE MATCH ENDS
        console.log(`${this.trainer1.name} has no more Pokémon left!`);
        game = false;
      }

      //CHECK IF TRAINER 2 HAVE REMAINING POKEMON
      if (this.trainer2.pokemonLeft()) {
        console.log(`${this.trainer2.name} has ${this.trainer2.pokemons.length} Pokémon left!`);
      } else {
        //IF NO POKEMON LEFT THE MATCH ENDS
        console.log(`${this.trainer2.name} has no more Pokémon left!`);
        game = false;
      }
    }

    //DETERMINE THE WINNER OF THE MATCH IF TRAINER1 HAVE REMAINING POKEMON
    if (this.trainer1.pokemonLeft()) {
      console.log(`${this.trainer1.name} wins the battle!`);
      this.trainer1.wins++;
    } else {
      console.log(`${this.trainer2.name} wins the battle!`);
      this.trainer2.wins++;
    }
  }
}

//CLASS OF INDIVIDUAL POKEMON BATTLE
class SingleBattle {
  constructor(pokemon1, pokemon2) {
    this.pokemon1 = pokemon1;
    this.pokemon2 = pokemon2;
  }

  //STAR THE BATTLE
  startBattle() {
    let game = true;

    while (game) {
      console.log(``);

      //SHOW POKEMON HP BEFORE EACH TURN
      console.log(`${this.pokemon1.name} HP: ${this.pokemon1.hp}`);
      console.log(`${this.pokemon2.name} HP: ${this.pokemon2.hp}`);
      console.log(
        `🔄 %c${this.pokemon1.name}` + " Turn to Attack",
        "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
      );

      this.pokemon1.attack(this.pokemon2);

      if (this.pokemon2.hp <= 0) {
        // console.log(`${this.pokemon2.name} has fainted!`);
        game = false;
        this.pokemon1.level++;
        console.log(`${this.pokemon1.name} has leveled up to level ${this.pokemon1.level}!`);
      } else {
        console.log(``);
        console.log(
          `🔄 %c${this.pokemon2.name}` + " Turn to Attack",
          "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
        );
        this.pokemon2.attack(this.pokemon1);

        if (this.pokemon1.hp <= 0) {
          // console.log(`${this.pokemon1.name} has fainted!`);
          game = false;
          this.pokemon2.level++;
          console.log(`${this.pokemon2.name} has leveled up to level ${this.pokemon2.level}!`);
        }
      }
    }
  }
}

//TOURNAMENT MODE
class Tournament {
  constructor(trainers) {
    this.trainers = trainers;
  }

  // Modify the reviveAndHealPokemon function to use originalPokemons
  reviveAndHealPokemon(trainers) {
    trainers.forEach((trainer) => {
      // Get all Pokémon, including dead ones
      const allPokemon = trainer.originalPokemons;

      // Revive and heal all Pokémon
      allPokemon.forEach((pokemon) => {
        pokemon.hp = 100; // Revive and heal Pokémon
        console.log(
          `%c${trainer.name}'s ${pokemon.name} has been revived and fully healed!`,
          "color: white; border: 1px solid white; padding: 2px; border-radius: 2px;"
        );
      });

      // Update the trainer's lineup with all revived Pokémon
      trainer.pokemons = allPokemon;
    });
  }

  //TOURNAMENT START
  startTournament() {
    //LOOP UNTIL ONE TRAINER REMAINS AND BECOME THE OVERALL WINNER
    while (true) {
      //FILTER OUT TRAINERS WITH AND HOW MANY POKEMONSREMAINING
      const remainingTrainers = this.trainers.filter((trainer) =>
        trainer.pokemons.some((pokemon) => !pokemon.isDead())
      );

      //CHECK IF THERE IS ONLY ONE TRAINER LEFT
      if (remainingTrainers.length <= 1) {
        //SHOW WINNER IF ONLY ONE TRAINER LEFT
        if (remainingTrainers.length === 1) {
          console.log(
            `%c 👑 The tournament is over! ${remainingTrainers[0].name}  is the overall winner! and Won ${remainingTrainers[0].wins} Matches 👑`,
            "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 30px; "
          );
        } else {
          console.log(`No winner, all trainers are out of Pokémon.`);
        }
        break;
      }

      //MATCH UP THE TRAINERS BASED ON COUNT AND MATCH IS DIFFERENT DEPENDING ON COUNT
      console.log(`${remainingTrainers.length} trainers remaining in the tournament.`);
      if (remainingTrainers.length === 3) {
        this.roundRobin(remainingTrainers);
      } else {
        this.bracketMatch(remainingTrainers);
      }
    }
  }

  //BRACKET MATCH
  bracketMatch(trainers) {
    //MATCH UP THE TRAINERS IN PAIR ACCORDING TO INDEX
    //WERE PARINGI UP TRAINERS IN BRACKET FORMAT WHERE EACH PAIR IS CONSIST OF TWO TRAINERS
    console.log("");
    console.log("BRACKET MATCH WILL BEGIN");
    for (let i = 0; i < trainers.length - 1; i += 2) {
      const trainer1 = trainers[i];
      const trainer2 = trainers[i + 1];
      console.log("");
      console.log(
        `       %c ⚔️  Match [${i + 1}] between ${trainer1.name} 🆚 ${trainer2.name}
        }-Wins ⚔️ `,
        "border: 1px solid #87CEEB; padding: 2px; border-radius: 2px; font-size: 20px; "
      );

      this.startMatch(trainer1, trainer2);
    }

    //IF THE NUMBER OF TRAINERS IS ODD THEN THE LAST TRAINER WILL BE MOVE INTO THE SEMI-FINAL
    if (trainers.length % 2 !== 0) {
      const lastTrainer = trainers[trainers.length - 1];
      console.log(
        `       %c  ${lastTrainer.name} Won by Default and Move into the Round Robin Format!`,
        "border: 1px solid black; padding: 2px; border-radius: 2px; font-size: 20px; "
      );
    }
  }

  //ROUND ROBIN
  roundRobin(trainers) {
    console.log("");
    console.log(
      "c%🏆ROUND ROBIN MATCH WILL BEGIN🏆",
      "border: 1px solid white; padding: 2px; border-radius: 2px; font-size: 25px; "
    );

    this.reviveAndHealPokemon(trainers); // Revive and heal all Pokémon

    // Revive and fully heal all Pokémon of remaining trainers
    // trainers.forEach((trainer) => {
    //   trainer.pokemons.forEach((pokemon) => {
    //     if (pokemon.isDead()) {
    //       // Revive fainted Pokémon
    //       pokemon.hp = 100; // Assume 100 is the max HP
    //       console.log(`${trainer.name}'s ${pokemon.name} has been revived and fully healed!`);
    //     } else {
    //       // Heal Pokémon that are not fainted
    //       pokemon.hp = 100;
    //       console.log(`${trainer.name}'s ${pokemon.name} has been fully healed!`);
    //     }
    //   });
    // });

    // Initialize a map to track wins for each trainer
    const winsMap = new Map();
    trainers.forEach((trainer) => winsMap.set(trainer, 0));

    //MATCH UP THE TRAINERS IN PAIR ACCORDING TO INDEX LOOP UNTIL THE LAST INDEX
    //THIS 2 FOR LOOP WILL RESULT 1 TRAINER WILL MATCH TO ALL REMAINING PLAYERS
    for (let i = 0; i < trainers.length; i++) {
      for (let j = i + 1; j < trainers.length; j++) {
        const trainer1 = trainers[i];
        const trainer2 = trainers[j];
        // Revive and heal all Pokémon for both trainers

        console.log("");
        console.log(
          `       %c ⚔️  Match [${i + 1}] between ${trainer1.name} 🆚 ${trainer2.name}
          }-Wins ⚔️ `,
          "border: 1px solid #87CEEB; padding: 2px; border-radius: 2px; font-size: 20px; "
        );
        this.reviveAndHealPokemon([trainer1, trainer2]);

        // Start a battle between trainers
        const battle = new Battle(trainer1.nextPokemon(), trainer2.nextPokemon(), trainer1, trainer2);
        battle.startBattle();

        // Update wins for the winner
        if (trainer1.pokemonLeft()) {
          winsMap.set(trainer1, winsMap.get(trainer1) + 1);
        } else if (trainer2.pokemonLeft()) {
          winsMap.set(trainer2, winsMap.get(trainer2) + 1);
        }

        console.log(
          `🏆 ${trainer1.name} Wins: ${winsMap.get(trainer1)} | ${trainer2.name} Wins: ${winsMap.get(trainer2)}`
        );
      }
    }
  }

  //START THE MATCH
  startMatch(trainer1, trainer2) {
    // Select valid Pokémon that is not dead
    const pokemon1 = trainer1.nextPokemon();
    const pokemon2 = trainer2.nextPokemon();

    // ERROR HANDLING CHECK IF ONE OR BOTH TRAINERS HAVE NO VALID POKEMON
    if (!pokemon1 || !pokemon2) {
      console.log(`Match cannot proceed. One or both trainers have no valid Pokémon.`);
      return;
    }

    //RANDOM POKEMON TO RECEIEVED POWER UP
    const powerUpPokemon = Math.random() < 0.5 ? pokemon1 : pokemon2;
    powerUpPokemon.powerUp();
    console.log(`🔥 ${powerUpPokemon.name} recieved power up before the battle begins`);

    const battle = new Battle(pokemon1, pokemon2, trainer1, trainer2);
    battle.startBattle();

    // Remove fainted Pokémon
    trainer1.pokemons = trainer1.pokemons.filter((pokemon) => !pokemon.isDead());

    trainer2.pokemons = trainer2.pokemons.filter((pokemon) => !pokemon.isDead());

    if (trainer1.pokemons.length === 0) {
      console.log(`${trainer1.name} is out of the tournament!`);
    }

    if (trainer2.pokemons.length === 0) {
      console.log(`${trainer2.name} is out of the tournament!`);
    }

    //RETURN THE WINNER OF THE MATCH
    return trainer1.pokemons.length > 0 ? trainer1 : trainer2;
  }
}

//CREATING POKEMON/ INSTANTIATE POKEMON
const charizard = new FirePokemon("Charizard", 10, 100, 0);
const stone = new RockPokemon("Stone", 10, 100, 0);
const starfish = new WaterPokemon("Starfish", 10, 100, 0);
const birdy = new GrassPokemon("Birdy", 10, 100, 0);
const gengar = new DarkPokemon("Gengar", 10, 100);
const charmander = new FirePokemon("Charmander", 10, 100, 0);
const machop = new RockPokemon("Machop", 10, 100, 0);
const squirtle = new WaterPokemon("Squirtle", 10, 100, 0);
const zubat = new GrassPokemon("Zubat", 10, 100, 0);
const mew = new DarkPokemon("Mew", 10, 100, 0);
const necrozma = new LightPokemon("Necrozma", 10, 100, 0);
const cosmoem = new LightPokemon("Cosmoem", 10, 100, 0);

//ARRAY OF POKEMON
let allPokemon = [
  charizard,
  stone,
  starfish,
  birdy,
  gengar,
  charmander,
  machop,
  squirtle,
  zubat,
  mew,
  necrozma,
  cosmoem,
];

//PROMTING IN FIRST ASK USER TO PUT # OF TRAINER AND POKEMON
//ADD DESIGN LATER
function startGame() {
  const trainers = [];

  // PROMPT ASK USER TO PUT # OF TRAINER
  let numberOfTrainer;
  while (isNaN(numberOfTrainer) || numberOfTrainer < 3 || numberOfTrainer > 5) {
    numberOfTrainer = parseInt(prompt("Enter Number of Trainers (Max 5)"));
    if (isNaN(numberOfTrainer)) {
      console.log("%cInvalid input. Please enter a number.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfTrainer < 3) {
      console.log("%cMinimum number of trainers is 3.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfTrainer > 5) {
      console.log("%cMaximum number of trainers is 5.", "color: red; font-weight: bold; font-size: 50px;");
    }
  }
  console.log(`%cDONE SELECTING NUMBER OF TRAINERS `, "color: green; font-weight: bold; font-size: 50px;");

  // PROMT ASK USER TO PUT # OF POKEMON
  let numberOfPokemon;
  //ERROR HANDLING IF INPUT IS NEGATIVE OR GREATER THAN 5
  while (isNaN(numberOfPokemon) || numberOfPokemon < 2 || numberOfPokemon > 5) {
    numberOfPokemon = parseInt(prompt("Enter Number of Pokekon (Max 5)"));
    if (isNaN(numberOfPokemon)) {
      console.log("%cInvalid input. Please enter a number.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfPokemon < 2) {
      console.log("%cMinimum number of Pokémon is 2.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfPokemon > 5) {
      console.log("%cMaximum number of Pokémon is 5.", "color: red; font-weight: bold; font-size: 50px;");
    }
  }
  console.log(`%cDONE SELECTING NUMBER OF POKEMONS `, "color: green; font-weight: bold; font-size: 50px;");

  // ADDING TRAINER NAME AND SELECTING POKEMON INSIDE A LOOP
  for (let i = 1; i <= numberOfTrainer; i++) {
    const name = prompt(`Enter the trainer ${i} Name: `);
    const newTrainer = new Trainer(name);
    trainers.push(newTrainer);

    // SELECTING POKEMON AFTER ADDING TRAINER
    for (let j = 1; j <= numberOfPokemon; j++) {
      // SHOWING ALL AVAILABLE POKEMON USING FOREACH FUNCTION
      console.log("");
      console.log("");
      console.log(
        `%c 👇SELECT POKEMON[${j}] POKEMON FROM AVAILABLE POKEMON FOR TRAINER: ▶${newTrainer.name}◀`,
        "color: white; font-weight: bold; font-size: 30px; border: 1px solid white; padding: 2px; border-radius: 10px;"
      );

      // FILTERING OUT ALL POKEMON THAT ARE ALREADY IN A TRAINER SO POKEMON WILL NOT REPEAT
      const availablePokemon = allPokemon.filter(
        (pokemon) => !trainers.some((trainer) => trainer.pokemons.includes(pokemon))
      );

      //SHOW ALL AVAILABLE POKEMON
      availablePokemon.forEach((pokemon, index) => {
        console.log(
          `%c[${index + 1}] ◓${pokemon.name} | ⭐LEVEL: ${pokemon.level} | ⚛TYPE:${pokemon.type} | ❤️HP:${pokemon.hp}`,
          "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
        );
      });

      // GETTING INPUT FROM USER TO SELECT POKEMON AND ENTER THE INDEX
      let selectedPokemonIndex;
      while (
        isNaN(selectedPokemonIndex) ||
        selectedPokemonIndex < 1 ||
        selectedPokemonIndex > availablePokemon.length
      ) {
        selectedPokemonIndex = parseInt(prompt(`Select Available Pokemon for ${newTrainer.name}: `));
        if (isNaN(selectedPokemonIndex)) {
          console.log("Invalid input. Please enter a number.");
        } else if (selectedPokemonIndex < 1) {
          console.log("Invalid input. Please enter a number between 1 and", availablePokemon.length);
        } else if (selectedPokemonIndex > availablePokemon.length) {
          console.log("Invalid input. Please enter a number between 1 and", availablePokemon.length);
        }
      }

      const selectedPokemon = availablePokemon[selectedPokemonIndex - 1]; // Subtract 1 to get the correct index based on user input

      console.log("");
      console.log(
        `%c${newTrainer.name} choose ${selectedPokemon.name} as their pokemon`,
        "color: red; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px; background-color: #FF69B4;"
      );
      newTrainer.choosePokemon(selectedPokemon);
    }
  }

  console.log("");

  // SHOWING ALL TEAM AND THEIR POKEMON USING MAP FUNCTION
  console.log(`%c╔═══════════════•●•═══════════════╗`, "color: red; font-weight: bold; font-size: 20px;");

  trainers.forEach((trainer) =>
    console.log(
      `   %c${trainer.name}'s team: ${trainer.pokemons.map((pokemon) => pokemon.name)}`,
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    )
  );

  console.log(`%c╚═══════════════•●•═══════════════╝`, "color: red; font-weight: bold; font-size: 20px;");

  // MENU
  while (true) {
    console.log("");

    console.log(
      "%c╔═════════════════《MAIN MENU》══════════════╗",
      "color: yellow; font-weight: bold; font-size: 20px;"
    );
    console.log(
      "          %c[1] - View Trainers' Pokémon",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[2] - Start Tournament",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[3] - Exit",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "%c╚═════════════════════《✧》══════════════════╝",
      "color: yellow; font-weight: bold; font-size: 20px;"
    );

    let choice;
    while (isNaN(choice) || choice < 1 || choice > 3) {
      choice = parseInt(prompt("Enter your choice"));
      if (isNaN(choice)) {
        console.log("Invalid input. Please enter a number.");
      } else if (choice < 1) {
        console.log("Please choose a valid option.");
      } else if (choice > 3) {
        console.log("Please choose a valid option.");
      }
    }

    switch (choice) {
      case 1:
        trainers.forEach((trainer) => {
          console.log("╔═══════════════•●•═══════════════╗");
          console.log(`  Trainer: ${trainer.name}`);
          trainer.showPokemon();
          console.log("╚═══════════════•●•═══════════════╝");
        });
        break;
      case 2:
        const tournament = new Tournament(trainers);
        tournament.startTournament();
        break;
      case 3:
        console.log("");
        console.log("Exiting...");
        return;
    }
  }
}

startGame();
