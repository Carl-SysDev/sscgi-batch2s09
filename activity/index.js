// console.log("test");

//             _
// _ __   ___ | | _____ _ __ ___   ___  _ __
// | '_ \ / _ \| |/ / _ \ '_ ` _ \ / _ \| '_ \
// | |_) | (_) |   <  __/ | | | | | (_) | | | |
// | .__/ \___/|_|\_\___|_| |_| |_|\___/|_| |_|
// |_|

// console.log("%c This is a colored log", "color: blue; font-size: 16px;");

// console.log(`
// ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú
// ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú
// ‚¨ú‚¨ú‚¨ú‚¨õ‚¨õüü•üü•üü•üü•üü•‚¨õ‚¨ú‚¨ú‚¨ú
// ‚¨ú‚¨ú‚¨õüü•üü•üü•üü•üü•üü•üü•üü•‚¨õ‚¨ú‚¨ú
// ‚¨ú‚¨õüü•üü•üü•üü•üü•üü•üü•üü•üü•üü•‚¨õ‚¨ú
// ‚¨ú‚¨õüü•üü•üü•üü•üü•üü•üü•üü•üü•üü•‚¨õ‚¨ú
// ‚¨õüü•üü•üü•üü•üü•‚¨õ‚¨õüü•üü•üü•üü•üü•‚¨õ
// ‚¨õüü•üü•üü•üü•‚¨õ‚¨ú‚¨ú‚¨õüü•üü•üü•üü•‚¨õ
// ‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ‚¨ú‚¨ú‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ
// ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ
// ‚¨ú‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨ú
// ‚¨ú‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨ú
// ‚¨ú‚¨ú‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨ú‚¨ú
// ‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú
// ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú
// ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú‚¨õ‚¨õ‚¨õ‚¨õ‚¨ú‚¨ú‚¨ú‚¨ú‚¨ú `);

console.log("");
console.log("");
console.log("");
console.log("");
console.log("");
console.log("");
console.log("");
console.log("");

console.log(
  `%c
‚£∑‚£ø‚£ø‚£∂‚£∂‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£¥‚¢∞‚£∂‚£∑‚£ø‚£ø
‚†Ä‚†π‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†à‚†ì‚†¶‚£Ñ‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°§‚†ñ‚†ä‚†â‚†Ä‚£∏‚£ø‚£ø‚£Ω‚†É
‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†∂‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚†É‚†Ä
‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†≥‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°§‚†ô‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°∏‚£ø‚†ü‚†Å‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢æ‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†±‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†ü‚†Å‚°Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†≥‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†≥‚°Ü‚£§‚†¥‚†û‚†õ‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†≥‚†Ü‚£§‚£§‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚†ñ‚†Å‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°†‚†ñ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢≥‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢á‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°æ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚£†‚£∂‚†ñ‚¢§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†¥‚†∂‚£¶‚°Ñ‚†Ä‚†Ä‚¢à‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†æ‚†Ä‚†Ä‚¢∞‚£æ‚£∑‚£Ä‚£∞‚°ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£Ä‚£†‚£æ‚£ø‚†Ä‚†Ä‚†Ä‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ü‚†Ä‚†Ä‚†à‚†ª‚£ç‚°©‚†ú‚†É‚†Ä‚†Ä‚†Ä‚††‚£§‚°§‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚†≠‚£â‚†Ω‚†è‚†Ä‚†Ä‚†Ä‚°∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†¥‚†¥‚£§‚£†‚£á‚£§‚£§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚£§‚£§‚£º‚£Ä‚°¥‚¢¥‚¢¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚°Å‚£Ä‚°Ä‚†ô‚£±‚°Ä‚†Ä‚†Ä‚†Ä‚†≤‚£Ñ‚£†‚°¥‚£í‚¢í‚£§‚£§‚†¥‚†Ç‚†Ä‚†Ä‚†Ä‚¢†‚°û‚¢Å‚£Ä‚°Ä‚¢®‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†Ä‚†â‚†Ä‚†à‚†à‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†à‚†Ä‚†â‚†â‚†â‚†â‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†â‚†â‚†â‚†â‚†â‚†Å‚†à‚†à‚†à‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`,
  "color: yellow;"
);
console.log("%c             _", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c _ __   ___ | | _____ _ __ ___   ___  _ __", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c| '_  / _ | |/ / _  '_ ` _  / _ | '_ \\ ", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log("%c| |_) | (_) |   <  __/ | | | | | (_) | | | |", "color: #FF69B4; font-size: 16px; font-weight: bold;");
console.log(
  "%c| .__/ \\___/|_|\\_\\___|_| |_| |_|\\___/|_| |_|        ",
  "color: #FF69B4; font-size: 16px; font-weight: bold;"
);
console.log(
  "%c|_|                                                    ",
  "color: #FF69B4; font-size: 16px; font-weight: bold;"
);

//POKEMON BASE CLASS

class Pokemon {
  constructor(name, type, level, hp, def) {
    this.name = name;
    this.type = type;
    this.level = level;
    this.hp = hp;
    // this.atk = atk;
    this.def = def;
  }

  attack(opponent) {
    console.log(`${this.name} attacked ${opponent.name}`);
    let lvl = this.level * 2;
  }

  receivedDamage(damage) {
    this.hp -= damage;
    if (this.hp <= 0) {
      console.log(`${this.name} has fainted`);
    } else {
      console.log(`${this.name} has ${this.hp} HP left`);
    }
  }

  heal() {
    let randomhp = Math.floor(Math.random() * (15 - 5)) + 5;
    let defboost = (this.def = +5);
    this.hp = Math.min(this.hp + defboost + randomhp, 100); // THIS CODE LET HP NOT EXCEED 100
    console.log(`${this.name} active unique passive skill and gained [${defboost}] Defense and heal [${randomhp}] HP `);
  }

  calculateDamage(opponentType, minDamage, maxDamage) {
    let isSuperEffective = false;
    const counterEffect = {
      Fire: "Rock",
      Rock: "Water",
      Water: "Grass",
      Grass: "Dark",
      Dark: "Light",
      Light: "Fire",
    };

    if (counterEffect[this.type] === opponentType) {
      isSuperEffective = true;
    }

    const dmgMultiplier = isSuperEffective ? 0.5 : 0.2;
    const damage = Math.floor(this.level * (Math.random() * (maxDamage - minDamage) + minDamage) * dmgMultiplier);

    console.log(
      `${this.name} deals ${damage} ${
        isSuperEffective ? "Critical Damage (Super Effective)" : "Damage"
      } to the Opponent`
    );

    return damage;
  }

  // criticalDamage() {
  //   let damage = this.level * Math.floor(Math.random() * (10 - 7)) + 7; //DEALING CRITCAL HIT ON MASMAHINA
  //   receivedDamage(damage);
  // }

  powerUp() {
    this.hp += 20;
    console.log(`${this.name} use PowerUpüí™ +20 HP ‚ù§Ô∏è`);
  }

  isDead() {
    return this.hp <= 0;
  }

  revive() {
    this.isDead = false;
    this.hp = 100;
  }
}

//TRAINERS
class Trainer {
  constructor(name) {
    this.name = name;
    this.pokemons = [];
    this.originalPokemons = [];
    this.wins = 0;
    this.overallWins = 0;
  }

  choosePokemon(pokemon) {
    // if (this.pokemons.length > 5) {
    //   console.log("You can only choose 6 Pokemon");
    // } else {
    this.pokemons.push(pokemon);
    this.originalPokemons.push(pokemon);
    console.log(
      `%c${this.name} add ${pokemon.name} in the Team`,
      "color: red; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px; background-color: #FF69B4;"
    );
    // }
  }

  selectPokemon(i) {
    return this.pokemons[i];
  }

  showPokemon() {
    // console.log(`${this.name}'s Pokemons: `);
    // this.pokemons.forEach((pokemon) => {
    //   console.log(`${pokemon.name}`);
    // });

    console.log(`  ${this.name}'s team: ${this.pokemons.map((pokemon) => pokemon.name)}`);
  }

  showOriginalPokemon() {
    console.log(`  ${this.name}'s team: ${this.originalPokemons.map((pokemon) => pokemon.name)}`);
  }

  showTrainerDetails() {}

  nextPokemon() {
    return this.pokemons.find((pokemon) => !pokemon.isDead());
  }

  pokemonLeft() {
    return this.pokemons.some((pokemon) => !pokemon.isDead());
  }

  deadPokemons() {
    return this.pokemons.filter((pokemon) => pokemon.isDead());
  }

  winCounts() {
    this.wins += 1;
    return console.log(`${this.wins} Wins`);
  }
}

//ADDING SUBCLASS USING POLYMORPSIM AND INHERITANCE
class FirePokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Fire", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use FlameThrowerüí• on ${opponent.name}!`,
      "border: 1px solid orange; padding: 2px; border-radius: 2px; background-color: orange; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Rock") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class RockPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Rock", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use RockDriveüí© on ${opponent.name}!`,
      "border: 1px solid brown; padding: 2px; border-radius: 2px; background-color: brown; color: white;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Water") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class WaterPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Water", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use WaterGunüí¶ on ${opponent.name}!`,
      "border: 1px solid skyblue; padding: 2px; border-radius: 2px; background-color: skyblue; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Grass") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class GrassPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Grass", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use VineWhipüå± on ${opponent.name}!`,
      "border: 1px solid #3E7B27; padding: 2px; border-radius: 2px; background-color: #3E7B27; color: white;"
    );

    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Dark") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class DarkPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Dark", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use BlackHoleüåë on ${opponent.name}!`,
      "border: 1px solid #3E5879; padding: 2px; border-radius: 2px; background-color: #3E5879; color: white;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Light") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

class LightPokemon extends Pokemon {
  constructor(name, level, hp) {
    super(name, "Light", level, hp);
  }

  attack(opponent) {
    console.log("");
    console.log(
      `%c${this.name} use Light Magic‚ú® on ${opponent.name}!`,
      "border: 1px solid #FFF574; padding: 2px; border-radius: 2px; background-color: #FFF574; color: black;"
    );
    let damage = this.calculateDamage(opponent.type, 6, 10); //DEALING CRITCAL HIT ON MASMAHINA
    opponent.receivedDamage(damage);
    if (opponent.type === "Fire") {
      console.log("SUPER EFFECTIVE");
      opponent.heal(); //UNIQUE SKILL HEAL
    }
  }
}

//BATTLEGROND
class Battle {
  //ADD TRAINER TO RECORD THE WINS
  constructor(pokemon1, pokemon2, trainer1, trainer2) {
    this.pokemon1 = pokemon1;
    this.pokemon2 = pokemon2;
    this.trainer1 = trainer1; //ADD THIS TO TRACK USER WIN AND LOOSE
    this.trainer2 = trainer2;
  }

  //START THE MATCH WITH POWER UPS WITHOUT POWER UP
  startBattle() {
    //console.log(`The battle Between ${this.trainer1.name} ‚ùå ${this.trainer2.name} has begun! `);
    console.log("");

    let game = true;

    while (game) {
      let pokemon1 = this.trainer1.nextPokemon();
      let pokemon2 = this.trainer2.nextPokemon();

      //CHECK IF TRAINER HAVE REMAINING POKEMON IF DONT THE MATCH ENDS
      if (!pokemon1 || !pokemon2) {
        game = false;
        console.log("NO POKEMON REMAINING");
        break;
      }

      console.log(``);
      console.log(
        `%c ${this.trainer1.name}'s ${pokemon1.name} is battling against ${this.trainer2.name}'s ${pokemon2.name}! `,
        "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
      );

      //START THE BATTLE FOR ALL TRAINERS POKEMONS
      let battle = new SingleBattle(pokemon1, pokemon2);
      battle.startBattle();

      //CREATING NEW ARRAY TO REMOVE DEAD POKEMON FOR EACH TRAINER 1
      if (pokemon1.isDead()) {
        this.trainer1.pokemons = this.trainer1.pokemons.filter((pokemon) => pokemon !== pokemon1);
      }
      //CREATING NEW ARRAY TO REMOVE DEAD POKEMON FOR TRAINER 2
      if (pokemon2.isDead()) {
        this.trainer2.pokemons = this.trainer2.pokemons.filter((pokemon) => pokemon !== pokemon2);
      }

      //CHECK IF TRAINER 1 HAVE REMAINING POKEMON
      if (this.trainer1.pokemonLeft()) {
        console.log(`${this.trainer1.name} has ${this.trainer1.pokemons.length} Pok√©mon left!`);
      } else {
        //IF NO POKEMON LEFT THE MATCH ENDS
        console.log(`${this.trainer1.name} has no more Pok√©mon left!`);
        // this.trainer2.wins++;
        game = false;
      }

      //CHECK IF TRAINER 2 HAVE REMAINING POKEMON
      if (this.trainer2.pokemonLeft()) {
        console.log(`${this.trainer2.name} has ${this.trainer2.pokemons.length} Pok√©mon left!`);
      } else {
        //IF NO POKEMON LEFT THE MATCH ENDS
        console.log(`${this.trainer2.name} has no more Pok√©mon left!`);
        // this.trainer1.wins++;
        game = false;
      }
    }

    //DETERMINE THE WINNER OF THE MATCH IF TRAINER1 HAVE REMAINING POKEMON
    if (this.trainer1.pokemonLeft()) {
      console.log(`${this.trainer1.name} wins the battle!`);
      this.trainer1.overallWins += 1;
      // console.log(`${this.trainer1.wins} ${this.trainer1.name}`);
    } else {
      console.log(`${this.trainer2.name} wins the battle!`);
      this.trainer2.overallWins += 1;
      // console.log(`${this.trainer2.wins} ${this.trainer2.name}`);
    }
  }
}

//CLASS OF INDIVIDUAL POKEMON BATTLE
class SingleBattle {
  constructor(pokemon1, pokemon2) {
    this.pokemon1 = pokemon1;
    this.pokemon2 = pokemon2;
  }

  //STAR THE BATTLE
  startBattle() {
    let game = true;

    while (game) {
      console.log(``);

      //SHOW POKEMON HP BEFORE EACH TURN
      console.log(`${this.pokemon1.name} HP: ${this.pokemon1.hp}`);
      console.log(`${this.pokemon2.name} HP: ${this.pokemon2.hp}`);
      console.log(
        `üîÑ %c${this.pokemon1.name}` + " Turn to Attack",
        "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
      );

      this.pokemon1.attack(this.pokemon2);

      if (this.pokemon2.hp <= 0) {
        // console.log(`${this.pokemon2.name} has fainted!`);
        game = false;
        this.pokemon1.level++;
        console.log(`${this.pokemon1.name} has leveled up to level ${this.pokemon1.level}!`);
      } else {
        console.log(``);
        console.log(
          `üîÑ %c${this.pokemon2.name}` + " Turn to Attack",
          "border: 1px solid black; padding: 2px; border-radius: 2px; background-color: black; color: white;"
        );
        this.pokemon2.attack(this.pokemon1);

        if (this.pokemon1.hp <= 0) {
          // console.log(`${this.pokemon1.name} has fainted!`);
          game = false;
          this.pokemon2.level++;
          console.log(`${this.pokemon2.name} has leveled up to level ${this.pokemon2.level}!`);
        }
      }
    }
  }
}

//TOURNAMENT MODE
class Tournament {
  constructor(trainers) {
    this.trainers = trainers;
  }

  //reviveAndHealPokemon function to use originalPokemons to make hp 100
  reviveAndHealPokemon(trainers) {
    trainers.forEach((trainer) => {
      // Get all Pok√©mon, including dead ones
      const allPokemon = trainer.originalPokemons;

      // Revive and heal all Pok√©mon
      allPokemon.forEach((pokemon) => {
        pokemon.hp = 100; // Revive and heal Pok√©mon
        console.log(
          `%c${trainer.name}'s ${pokemon.name} has been revived and fully healed!`,
          "color: white; border: 1px solid white; padding: 2px; border-radius: 2px;"
        );
      });

      // Update the trainer's lineup with all revived Pok√©mon
      trainer.pokemons = allPokemon;
    });
  }

  //TOURNAMENT START
  startTournament() {
    //LOOP UNTIL ONE TRAINER REMAINS AND BECOME THE OVERALL WINNER
    while (true) {
      //FILTER OUT TRAINERS WITH AND HOW MANY POKEMONSREMAINING
      const remainingTrainers = this.trainers.filter((trainer) =>
        trainer.pokemons.some((pokemon) => !pokemon.isDead())
      );

      //CHECK IF THERE IS ONLY ONE TRAINER LEFT
      if (remainingTrainers.length <= 1) {
        //SHOW WINNER IF ONLY ONE TRAINER LEFT
        if (remainingTrainers.length === 1) {
          console.log(
            `%c üëë The tournament is over! ${remainingTrainers[0].name}  is the overall winner! üëë`,
            "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 25px; "
          );
        } else {
          console.log(`No winner, all trainers are out of Pok√©mon.`);
        }
        break;
      }
      //CHECK IF TRAINER HAVE 2 WINS FOR ROUND ROBIN
      else if (remainingTrainers.length === 2) {
        if (remainingTrainers[0].wins === 2) {
          console.log(
            `%c üëë The tournament is over! ${remainingTrainers[0].name}  is the overall winner! üëë`,
            "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 25px; "
          );
          break;
        } else if (remainingTrainers[1].wins === 2) {
          console.log(
            `%c üëë The tournament is over! ${remainingTrainers[1].name}  is the overall winner! üëë`,
            "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 25px; "
          );
          break;
        }
      }

      //MATCH UP THE TRAINERS BASED ON COUNT AND MATCH IS DIFFERENT DEPENDING ON COUNT
      console.log(`${remainingTrainers.length} trainers remaining in the tournament.`);
      if (remainingTrainers.length === 3) {
        this.roundRobin(remainingTrainers);
      } else {
        this.bracketMatch(remainingTrainers);
      }
    }
  }

  //BRACKET MATCH
  bracketMatch(trainers) {
    //MATCH UP THE TRAINERS IN PAIR ACCORDING TO INDEX
    //WERE PARINGI UP TRAINERS IN BRACKET FORMAT WHERE EACH PAIR IS CONSIST OF TWO TRAINERS

    console.log("");
    console.log(
      "%c üèÜ BRACKET MATCH WILL BEGIN üèÜ ",
      "border: 1px solid white; padding: 2px; border-radius: 2px; font-size: 25px; "
    );
    for (let i = 0; i < trainers.length - 1; i += 2) {
      const trainer1 = trainers[i];
      const trainer2 = trainers[i + 1];

      // //FIX THE BUG AFTER ROUND ROBIN THE MATCH WILL CONTINUE IN BRACKET MATCH
      // if (trainers.length === 2) {
      //   if (trainer1.wins > trainer2.wins) {
      //     console.log(
      //       `%c üëë The tournament is over! ${trainer1.name}  is the overall winner! üëë`,
      //       "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 25px; "
      //     );
      //     return; // Exit the function because break; is not working
      //   } else {
      //     console.log(
      //       `%c üëë The tournament is over! ${trainer2.name}  is the overall winner! üëë`,
      //       "border: 1px solid red; padding: 2px; border-radius: 2px; background-color: red; color: white; font-size: 25px; "
      //     );
      //     return; // Exit the function because break; is not working
      //   }
      // }

      console.log("");
      console.log(
        `       %c ‚öîÔ∏è  Match Between ${trainer1.name} üÜö ${trainer2.name} ‚öîÔ∏è `,
        "border: 1px solid #87CEEB; padding: 2px; border-radius: 2px; font-size: 20px; "
      );
      this.reviveAndHealPokemon([trainer1, trainer2]);
      this.startMatch(trainer1, trainer2);
    }

    //IF THE NUMBER OF TRAINERS IS ODD THEN THE LAST TRAINER WILL BE MOVE INTO THE SEMI-FINAL
    if (trainers.length % 2 !== 0) {
      const lastTrainer = trainers[trainers.length - 1];
      console.log(
        `       %c  ${lastTrainer.name} Won by Default and Move into the Round Robin Format!`,
        "border: 1px solid black; padding: 2px; border-radius: 2px; font-size: 20px; "
      );
    }
  }

  //ROUND ROBIN
  roundRobin(trainers) {
    console.log("");
    console.log(
      "%c üèÜROUND ROBIN MATCH WILL BEGINüèÜ ",
      "border: 1px solid white; padding: 2px; border-radius: 2px; font-size: 25px; "
    );

    this.reviveAndHealPokemon(trainers); // Revive and heal all Pok√©mon

    // Initialize a map to track wins for each trainer
    // const winsMap = new Map();
    // trainers.forEach((trainer) => winsMap.set(trainer, 0));

    //MATCH UP THE TRAINERS IN PAIR ACCORDING TO INDEX LOOP UNTIL THE LAST INDEX
    //THIS 2 FOR LOOP WILL RESULT 1 TRAINER WILL MATCH TO ALL REMAINING PLAYERS
    for (let i = 0; i < trainers.length; i++) {
      for (let j = i + 1; j < trainers.length; j++) {
        const trainer1 = trainers[i];
        const trainer2 = trainers[j];

        console.log("");
        console.log(
          `       %c ‚öîÔ∏è  Match Between ${trainer1.name} üÜö ${trainer2.name} ‚öîÔ∏è `,
          "border: 1px solid #87CEEB; padding: 2px; border-radius: 2px; font-size: 20px; "
        );

        this.reviveAndHealPokemon([trainer1, trainer2]);

        // // Start a match between the two trainers With PowerUp
        // this.startMatch(trainer1, trainer2);

        // Start a battle between trainers without powerUp
        const battle = new Battle(trainer1.nextPokemon(), trainer2.nextPokemon(), trainer1, trainer2);
        battle.startBattle();

        // Update wins for the winner
        if (trainer1.pokemonLeft()) {
          // winsMap.set(trainer1, winsMap.get(trainer1) + 1);
          trainer1.wins += 1;
        } else if (trainer2.pokemonLeft()) {
          // winsMap.set(trainer2, winsMap.get(trainer2) + 1);
          trainer2.wins += 1;
        }

        //DISPLAY THE WINS IN ROUND ROBIN NOT INCLUDED THE BRACKET MATCH
        // console.log(
        //   `üèÜ ${trainer1.name} Wins: ${winsMap.get(trainer1)} | ${trainer2.name} Wins: ${winsMap.get(trainer2)}`
        // );

        console.log(`üèÜ ${trainer1.name} Wins: ${trainer1.wins} | ${trainer2.name} Wins: ${trainer2.wins} üèÜ`);
      }
    }
  }

  //START THE MATCH WITH POWER UPS
  startMatch(trainer1, trainer2) {
    // Select valid Pok√©mon that is not dead
    const pokemon1 = trainer1.nextPokemon();
    const pokemon2 = trainer2.nextPokemon();

    // ERROR HANDLING CHECK IF ONE OR BOTH TRAINERS HAVE NO VALID POKEMON
    if (!pokemon1 || !pokemon2) {
      console.log(`Match cannot proceed. One or both trainers have no valid Pok√©mon.`);
      return;
    }

    //RANDOM POKEMON TO RECEIEVED POWER UP
    const powerUpPokemon = Math.random() < 0.5 ? pokemon1 : pokemon2;
    powerUpPokemon.powerUp();
    console.log(`üî• ${powerUpPokemon.name} recieved power up before the battle begins`);

    const battle = new Battle(pokemon1, pokemon2, trainer1, trainer2);
    battle.startBattle();

    // Remove fainted Pok√©mon
    trainer1.pokemons = trainer1.pokemons.filter((pokemon) => !pokemon.isDead());

    trainer2.pokemons = trainer2.pokemons.filter((pokemon) => !pokemon.isDead());

    if (trainer1.pokemons.length === 0) {
      console.log(`${trainer1.name} is out of the tournament!`);
    }

    if (trainer2.pokemons.length === 0) {
      console.log(`${trainer2.name} is out of the tournament!`);
    }

    //RETURN THE WINNER OF THE MATCH
    return trainer1.pokemons.length > 0 ? trainer1 : trainer2;
  }
}

//CREATING POKEMON/ INSTANTIATE POKEMON
const charizard = new FirePokemon("Charizard", 10, 100, 0);
const stone = new RockPokemon("Stone", 10, 100, 0);
const starfish = new WaterPokemon("Starfish", 10, 100, 0);
const birdy = new GrassPokemon("Birdy", 10, 100, 0);
const gengar = new DarkPokemon("Gengar", 10, 100, 0);
const charmander = new FirePokemon("Charmander", 10, 100, 0);
const machop = new RockPokemon("Machop", 10, 100, 0);
const squirtle = new WaterPokemon("Squirtle", 10, 100, 0);
const zubat = new GrassPokemon("Zubat", 10, 100, 0);
const mew = new DarkPokemon("Mew", 10, 100, 0);
const necrozma = new LightPokemon("Necrozma", 10, 100, 0);
const cosmoem = new LightPokemon("Cosmoem", 10, 100, 0);
const emboar = new FirePokemon("Emboar", 10, 100, 0);
const onix = new RockPokemon("Onix", 10, 100, 0);
const psyduck = new WaterPokemon("Psyduck", 10, 100, 0);
const leafeon = new GrassPokemon("Lefeon", 10, 100, 0);
const poochyena = new DarkPokemon("Poochyena", 10, 100, 0);
const lumeon = new LightPokemon("Lumeon", 10, 100, 0);
const vulpix = new FirePokemon("Vulpix", 10, 100, 0);
const omanyte = new RockPokemon("Omanyte", 10, 100, 0);
const goldeen = new WaterPokemon("Goldeen", 10, 100, 0);
const chikorita = new GrassPokemon("Chikorita", 10, 100, 0);
const houndoom = new DarkPokemon("Houndoom", 10, 100, 0);
const luxray = new LightPokemon("Luxray", 10, 100, 0);
const flareon = new FirePokemon("Flareon", 10, 100, 0);

//ARRAY OF POKEMON
let allPokemon = [
  charizard,
  stone,
  starfish,
  birdy,
  cosmoem,
  chikorita,
  houndoom,
  luxray,
  emboar,
  onix,
  gengar,
  charmander,
  machop,
  squirtle,
  zubat,
  mew,
  necrozma,
  vulpix,
  omanyte,
  goldeen,
  psyduck,
  leafeon,
  poochyena,
  lumeon,
  flareon,
];

//PROMTING IN FIRST ASK USER TO PUT # OF TRAINER AND POKEMON
//ADD DESIGN LATER
function startGame() {
  const trainers = [];

  // PROMPT ASK USER TO PUT # OF TRAINER
  let numberOfTrainer;
  while (isNaN(numberOfTrainer) || numberOfTrainer < 3 || numberOfTrainer > 5) {
    numberOfTrainer = parseInt(prompt("Enter Number of Trainers (Max 5)"));
    if (isNaN(numberOfTrainer)) {
      console.log("%cInvalid input. Please enter a number.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfTrainer < 3) {
      console.log("%cMinimum number of trainers is 3.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfTrainer > 5) {
      console.log("%cMaximum number of trainers is 5.", "color: red; font-weight: bold; font-size: 50px;");
    }
  }
  console.log(`%cDONE SELECTING NUMBER OF TRAINERS `, "color: green; font-weight: bold; font-size: 50px;");

  // PROMT ASK USER TO PUT # OF POKEMON
  let numberOfPokemon;
  //ERROR HANDLING IF INPUT IS NEGATIVE OR GREATER THAN 5
  while (isNaN(numberOfPokemon) || numberOfPokemon < 2 || numberOfPokemon > 5) {
    numberOfPokemon = parseInt(prompt("Enter Number of Pokekon (Max 5)"));
    if (isNaN(numberOfPokemon)) {
      console.log("%cInvalid input. Please enter a number.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfPokemon < 2) {
      console.log("%cMinimum number of Pok√©mon is 2.", "color: red; font-weight: bold; font-size: 50px;");
    } else if (numberOfPokemon > 5) {
      console.log("%cMaximum number of Pok√©mon is 5.", "color: red; font-weight: bold; font-size: 50px;");
    }
  }
  console.log(`%cDONE SELECTING NUMBER OF POKEMONS `, "color: green; font-weight: bold; font-size: 50px;");

  // ADDING TRAINER NAME AND SELECTING POKEMON INSIDE A LOOP
  for (let i = 1; i <= numberOfTrainer; i++) {
    const name = prompt(`Enter the trainer ${i} Name: `);
    const newTrainer = new Trainer(name);
    trainers.push(newTrainer);

    // SELECTING POKEMON AFTER ADDING TRAINER
    for (let j = 1; j <= numberOfPokemon; j++) {
      // SHOWING ALL AVAILABLE POKEMON USING FOREACH FUNCTION
      console.log("");
      console.log("");
      console.log(
        `%c üëáSELECT POKEMON[${j}] POKEMON FROM AVAILABLE POKEMON FOR TRAINER: ‚ñ∂${newTrainer.name}‚óÄ`,
        "color: white; font-weight: bold; font-size: 30px; border: 1px solid white; padding: 2px; border-radius: 10px;"
      );

      // FILTERING OUT ALL POKEMON THAT ARE ALREADY IN A TRAINER SO POKEMON WILL NOT REPEAT
      const availablePokemon = allPokemon.filter(
        (pokemon) => !trainers.some((trainer) => trainer.pokemons.includes(pokemon))
      );

      //SHOW ALL AVAILABLE POKEMON
      availablePokemon.forEach((pokemon, index) => {
        console.log(
          `%c[${index + 1}] ‚óì${pokemon.name} | ‚≠êLEVEL: ${pokemon.level} | ‚öõTYPE:${pokemon.type} | ‚ù§Ô∏èHP:${pokemon.hp}`,
          "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
        );
      });

      // GETTING INPUT FROM USER TO SELECT POKEMON AND ENTER THE INDEX
      let selectedPokemonIndex;
      while (
        isNaN(selectedPokemonIndex) ||
        selectedPokemonIndex < 1 ||
        selectedPokemonIndex > availablePokemon.length
      ) {
        selectedPokemonIndex = parseInt(prompt(`Select Available Pokemon for ${newTrainer.name}: `));
        if (isNaN(selectedPokemonIndex)) {
          console.log("Invalid input. Please enter a number.");
        } else if (selectedPokemonIndex < 1) {
          console.log("Invalid input. Please enter a number between 1 and", availablePokemon.length);
        } else if (selectedPokemonIndex > availablePokemon.length) {
          console.log("Invalid input. Please enter a number between 1 and", availablePokemon.length);
        }
      }

      const selectedPokemon = availablePokemon[selectedPokemonIndex - 1]; // Subtract 1 to get the correct index based on user input

      console.log("");
      console.log(
        `%c${newTrainer.name} choose ${selectedPokemon.name} as their pokemon`,
        "color: red; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px; background-color: #FF69B4;"
      );
      newTrainer.choosePokemon(selectedPokemon);
    }
  }

  console.log("");

  // SHOWING ALL TEAM AND THEIR POKEMON USING MAP FUNCTION
  console.log(`%c‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚óè‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`, "color: red; font-weight: bold; font-size: 20px;");

  trainers.forEach((trainer) =>
    console.log(
      `   %c${trainer.name}'s team: ${trainer.pokemons.map((pokemon) => pokemon.name)}`,
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    )
  );

  console.log(`%c‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚óè‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`, "color: red; font-weight: bold; font-size: 20px;");

  // MENU
  while (true) {
    console.log("");

    console.log(
      "%c‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê„ÄäMAIN MENU„Äã‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó",
      "color: yellow; font-weight: bold; font-size: 20px;"
    );
    console.log(
      "          %c[1] - View Trainers' Pok√©mon",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[2] - Start Tournament",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[3] - Show Rankings",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "          %c[4] - Exit",
      "color: white; font-weight: bold; font-size: 15px; border: 1px solid white; padding: 2px; border-radius: 10px;"
    );
    console.log(
      "%c‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê„Ää‚úß„Äã‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù",
      "color: yellow; font-weight: bold; font-size: 20px;"
    );

    let choice;
    while (isNaN(choice) || choice < 1 || choice > 4) {
      choice = parseInt(prompt("Enter your choice"));
      if (isNaN(choice)) {
        console.log("Invalid input. Please enter a number.");
      } else if (choice < 1) {
        console.log("Please choose a valid option.");
      } else if (choice > 4) {
        console.log("Please choose a valid option.");
      }
    }

    switch (choice) {
      case 1:
        console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚óè‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        trainers.forEach((trainer) => {
          console.log(`  Trainer: ${trainer.name}`);
          trainer.showOriginalPokemon();
        });
        console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚óè‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        break;
      case 2:
        const tournament = new Tournament(trainers);
        tournament.startTournament();
        break;
      case 3:
        if (trainers.every((trainer) => trainer.wins === 0)) {
          console.log("All trainers must have to fight first before showing the rankings.");

          break;
        } else {
          //SHOW RANKINGS BASED ON WINS
          console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚óè‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
          trainers
            .sort((a, b) => b.wins + b.overallWins - (a.wins + a.overallWins))
            .forEach((trainer) => {
              console.log(`  Trainer: ${trainer.name} = Wins: ${trainer.wins + trainer.overallWins}`);
            });

          console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚óè‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
          break;
        }

      case 4:
        console.log("");
        console.log("Exiting...");
        return;
    }
  }
}

startGame();
